---
title: "프로그래머스 - 리코쳇 로봇"
category: "Algorithms"
tags: ["Algorithms", "Search", "BFS"]
date: 2024-11-17
last_modified_at: 2024-11-17
---

# 리코쳇 로봇

<img src="https://img.shields.io/badge/-프로그래머스-1e2a3c" alt="프로그래머스"/> <img src="https://img.shields.io/badge/-Level 2-green" alt="Level 2"/> <img src="https://img.shields.io/badge/-BFS-mediumpurple" alt="BFS"/> 

- [문제 풀러 가기](https://school.programmers.co.kr/learn/courses/30/lessons/169199)

### 풀이 1:

```js
function solution(board) {
    const m = board.length;
    const n = board[0].length;
    
    const dx = [0, 0, -1, 1];
    const dy = [-1, 1, 0, 0];

    let reset;
    let goal;
    
    // O(m*n)
    const matrix = board.map((rows, i) => {
        return [...rows].map((node, j) => {
            if(node === 'D')    return node;
            if(node === 'R')    reset = [i, j];
            if(node === 'G')    goal = [i, j];
            
            return 0;
        })
    });
    
    function bfs(matrix, reset){
        const q = [ reset ];
        const visited = Array.from({ length: m }, () => new Array(n).fill(0));
        
        while(q.length){
            const [y, x] = q.shift();
      
            if(visited[y][x] === 0){
                if(x === goal[1] && y === goal[0])  return matrix[y][x];

                visited[y][x] = 1;
                
                // 상, 하, 좌, 우
                dx.forEach((_, i)=> {      
                    let nx = x;
                    let ny = y;
                    
                    while(true){
                        if(nx + dx[i] >= n || nx + dx[i] < 0 || ny + dy[i] >= m || ny + dy[i] < 0){
                            break;
                        };
                        
                        if(matrix[ny + dy[i]][nx + dx[i]] === 'D'){
                            break;
                        } 
                        
                        nx += dx[i];
                        ny += dy[i];
                    }
                    
                    if(nx === x && ny === y)     return;
                   
                    if(!matrix[ny][nx] && !visited[ny][nx]){
                        matrix[ny][nx] = matrix[y][x] + 1;
                        q.push([ny, nx]);
                    } 
                });
            }
        }
        
        return -1;
    }
    
    return bfs(matrix, reset);
}
```

## Review 

#### 제한 사항
- 3 ≤ board의 길이 ≤ 100
    - 3 ≤ board의 원소의 길이 ≤ 100
        - board의 원소의 길이는 모두 동일합니다.
        - 문자열은 ".", "D", "R", "G"로만 구성되어 있으며 각각 빈 공간, 장애물, 로봇의 처음 위치, 목표 지점을 나타냅니다.
        - "R"과 "G"는 한 번씩 등장합니다.
